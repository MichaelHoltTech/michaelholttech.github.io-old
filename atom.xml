<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[A Church MacAdmin's Blog]]></title>
  <link href="http://www.mholt.tech/atom.xml" rel="self"/>
  <link href="http://www.mholt.tech/"/>
  <updated>2015-12-05T00:51:56-08:00</updated>
  <id>http://www.mholt.tech/</id>
  <author>
    <name><![CDATA[Michael Holt]]></name>
    <email><![CDATA[info@mholt.tech]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Getting Started With Puppet]]></title>
    <link href="http://www.mholt.tech/blog/2015/12/04/getting-started-with-puppet/"/>
    <updated>2015-12-04T17:04:01-08:00</updated>
    <id>http://www.mholt.tech/blog/2015/12/04/getting-started-with-puppet</id>
    <content type="html"><![CDATA[<p>Back at the Church IT Roundtable in October I began sharing about how we have implemented a Mac Management solution using Open Source Tools and I promised to provide tutorials on how to get started.  I’ve spent the time rebuilding the Docker Container to automate the setup of a new Puppet Server because of some issues that my original container experiences on occasion.  This post is going to cover the basics of getting Docker &amp; Puppet up and running on a Ubuntu 14.04 server running Docker.  At the end of this post, you’ll have a working puppetserver and a mac checking into it.  Future posts will expand on how to use Puppet to configure your mac as well as the other parts of our environment mentioned in the <a href="http://www.mholt.tech/blog/2015/10/08/our-path-to-mac-management/">previous post</a>.</p>

<!--more-->

<h3 id="installing-docker">Installing Docker</h3>

<p>I’m going to assume you already have a working Ubuntu 14.04 Server.  If not, I Highly recommend using Linode, which is what we use to run our Management Platform.  You can sign up <a href="https://www.linode.com/?r=eb7892d4b2b5528c799c9bab969491ae8b02970a">Here</a>.</p>

<p>Our first job after SSH’ing into the server is to get Docker installed.  This is a very easy process.</p>

<p>First lets makes sure we have <code>wget</code> installed:</p>

<div class="bogus-wrapper"><notextile><figure class="code panel panel-default"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">which wget</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>If nothing is returned, we need to install <code>wget</code>:</p>

<div class="bogus-wrapper"><notextile><figure class="code panel panel-default"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">sudo apt-get update
</span><span class="line">sudo apt-get install wget</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>And now we can install Docker.</p>

<div class="bogus-wrapper"><notextile><figure class="code panel panel-default"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">wget -qO- https://get.docker.com/ | sh</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Enter your password when asked and then you’re done.</p>

<p>If you aren’t running as root (which isn’t secure anyways so I hope you aren’t), you can give a user access to Docker without having to grant sudo and preface all docker commands with sudo.  This can be done by running</p>

<div class="bogus-wrapper"><notextile><figure class="code panel panel-default"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">sudo usermod -aG docker &lt;username&gt;</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="clone-the-core-repo">Clone the Core Repo</h3>
<p>Now before we continue with docker we need to clone the base configuration that our Puppetserver will be using.  I’m going to go with the assumption that you are familiar with git.  If this is you’re first time there are a lot of tutorials on the internet, personally I like to use a GUI and recommend <a href="https://www.sourcetreeapp.com/">SourceTree</a>.</p>

<p>This is also going to be based on using Bitbucket for storing your configurations privately.  Bitbucket gives you unlimited <em>PRIVATE</em> repositories for free which I highly recommend doing to keep your configuration data private.  This is also compatible with GitHub as well.  You can get a BitBucket account <a href="https://bitbucket.org/">here</a>.</p>

<p>Here’s how to get started with your own copy of the Core Repository:</p>

<ol>
  <li>To start off, go to Bitbucket’s website and log in.</li>
  <li>Go to Repositories -&gt; Import Repository</li>
  <li>For <strong>URL</strong>, enter: https://github.com/MichaelHoltTech/puppet-core_repo.git</li>
  <li>For <strong>Name</strong>, you may keep the name of the imported repository or change this to anything you want.</li>
  <li>For <strong>Access Level</strong>, make sure to check “This is a private repository”</li>
  <li>Click <strong>Import Repository</strong> to import the base repository into your Bitbucket account.  It’ll take a moment for the code to import and then you can continue.</li>
</ol>

<h3 id="start-setting-up-puppetserver">Start setting up Puppetserver</h3>

<p>Now we’re ready to go back to Docker and start setting up Puppetserver.  This is a very simple process.</p>

<p>We’ll start off with creating what is called a Volume Container.  This will store the SSL Certificates used by Puppet so that the container can be updated as needed without worrying about losing some important configuration.</p>

<p>On your Ubuntu server, start by running this command. <em>Note: If you are not logged in with root then preface all commands from here on out with sudo</em></p>

<div class="bogus-wrapper"><notextile><figure class="code panel panel-default"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class=""><span class="line">docker pull busybox
</span><span class="line">docker run -d --name data_puppet \
</span><span class="line">  -v /root/.ssh \
</span><span class="line">  -v /var/lib/puppet/ssl \
</span><span class="line">  busybox</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Now we have to create a file in order for the Puppetserver to know how to get your Core Repository.  If you skip this step you’ll run into some issues when we get to restarting the container.  I prefer nano, but you use whatever editor you prefer on the Linux Server.</p>

<p>To begin, lets create some directories and grant all users inside of the Docker user group access.</p>

<div class="bogus-wrapper"><notextile><figure class="code panel panel-default"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class=""><span class="line">sudo mkdir -p /usr/local/docker/puppetserver
</span><span class="line">sudo chgrp -R docker /usr/local/docker
</span><span class="line">sudo chmod -R 770 /usr/local/docker
</span><span class="line">cd /usr/local/docker/puppetserver
</span><span class="line">nano custom.yaml</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Inside of custom.yaml insert the following contents, replacing the repo url in single quotes with repo’s SSH URL found by clicking: … -&gt; Clone -&gt; Change HTTPS to SSH.</p>

<div class="bogus-wrapper"><notextile><figure class="code panel panel-default"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">---
</span><span class="line">repo_url: 'git@github.com:MichaelHoltTech/puppet-core_repo.git'</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Now lets go ahead and close and save this file</p>

<p>Now that we have that out of the way we can get started with the Puppetserver.  Make sure you replace <code>puppet.example.com</code> with the url/hostname you intend to use for your puppet server.</p>

<div class="bogus-wrapper"><notextile><figure class="code panel panel-default"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
</pre></td><td class="code"><pre><code class=""><span class="line">docker pull michaelholttech/puppetserver
</span><span class="line">docker run -d --name=puppetserver \
</span><span class="line">  --volumes-from data_puppet \
</span><span class="line">  -v /root/.ssh \
</span><span class="line">  -v /var/lib/puppet/ssl \
</span><span class="line">  -v /usr/local/docker/puppetserver/custom.yaml:/root/bootstrap/hiera/data/custom.yaml \
</span><span class="line">  -e PUPPETSERVER_JAVA_ARGS="-Xms384m -Xmx384m -XX:MaxPermSize=256m" \
</span><span class="line">  -p 8140:8140 \
</span><span class="line">  -h puppet.example.com \
</span><span class="line">  --restart="always" \
</span><span class="line">  michaelholttech/puppetserver</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>After you have run those commands we need to monitor the logs for some important information that will be provided.  This can be done by running:</p>

<div class="bogus-wrapper"><notextile><figure class="code panel panel-default"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">docker logs -f puppetserver</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Once the initial scripts have run you’ll see Public Key displayed in the logs.  You need to take this and enter it as a Deployment Key for your Repository.  This can be done by browsing to your repository on the Bitbucket Website, and then going to Setttings -&gt; Deployment Keys -&gt; Add Key.  Copy/Paste the Publickey starting with <code>ssh-rsa</code> and ending with <code>R10K Deployment Key</code></p>

<p>Now that we’ve gotten that done we’re ready to let Puppet finish bootstraping itself.  This can be done by copy/pasting the commands after the Publickey in the  logs that were looking at in the last step.  You can also run:</p>

<div class="bogus-wrapper"><notextile><figure class="code panel panel-default"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">docker stop puppetserver
</span><span class="line">docker start puppetserver</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Now if you watch the logs again you can see puppet preparing itself</p>

<div class="bogus-wrapper"><notextile><figure class="code panel panel-default"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">docker logs -f puppetserver</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>This will take several minutes to complete.  When it is done you will see a line saying <code>[p.s.m.master-service] Puppet Server has successfully started and is now ready to handle requests</code></p>

<p>Now that your puppetserver is running there’s only one last command to run.  This command is only needed if there isn’t already data existing inside of <code>data_puppet</code>.  This command is also set up to automatically run ever 30 minutes inside of the container.</p>

<div class="bogus-wrapper"><notextile><figure class="code panel panel-default"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">docker exec -it puppetserver puppet agent -t</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="set-up-youre-first-client">Set up you’re first client!</h3>

<p>Whew we’re almost there.  Not much longer until you will have your first client checking into your brand new Puppetserver.</p>

<p>Let’s start with a fresh Mac OS environment, be it a VM or spare computer.  We’re going to have to start off by installing two packages on the machine… Puppet &amp; Facter.</p>

<p>Puppet v3.8.4 can be downloaded <a href="https://downloads.puppetlabs.com/mac/puppet-3.8.4.dmg"><strong>HERE</strong></a>.</p>

<p>Facter v2.4.4 can be downloaded <a href="https://downloads.puppetlabs.com/mac/facter-2.4.4.dmg"><strong>HERE</strong></a>.</p>

<p>Once downloaded go ahead and install these onto your test machine.</p>

<p>At this point all that’s left is to get your machine configured.  This is extremly simple and can be done with running one command in terminal, replacing <code>puppet.example.com</code> with your puppetserver’s URL.  <em>If you don’t have a DNS record for it, make sure you add a manual entry inside of <code>/etc/hosts</code> on your test machine!</em></p>

<div class="bogus-wrapper"><notextile><figure class="code panel panel-default"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">sudo puppet agent -t --certname $(ioreg -l | awk '/IOPlatformSerialNumber/ { split($0, line, "\""); printf("%s\n", line[4]); }' | tr '[:upper:]' '[:lower:]') --waitforcert 20 --server puppet.example.com</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>You now have your first machine up and running on Puppet! Congratulations!</p>

<p>There’s plenty of information online if you want to begin playing with some configuration settings inside of the Core Repository.</p>

<p>We’ll go over this more in a future post, but to configure a role we need to create a fact on the local machine.  This can be done by running:</p>

<div class="bogus-wrapper"><notextile><figure class="code panel panel-default"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">sudo mkdir -p /etc/facter/facts.d
</span><span class="line">sudo nano /etc/facter/facts.d/computer_role.yaml</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Paste the following inside of <code>computer_role.yaml</code></p>

<div class="bogus-wrapper"><notextile><figure class="code panel panel-default"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">---
</span><span class="line">computer_role: "test"</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Since the machine is now configured with puppet, you can trigger puppet by running a much simpler command:</p>

<div class="bogus-wrapper"><notextile><figure class="code panel panel-default"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">sudo puppet agent -t</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>If you have added the computer_role fact, you should get an output similar to the following when you run <code>puppet agent -t</code>:</p>

<div class="bogus-wrapper"><notextile><figure class="code panel panel-default"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
</pre></td><td class="code"><pre><code class=""><span class="line">Info: Retrieving pluginfacts
</span><span class="line">Info: Retrieving plugin
</span><span class="line">Info: Loading facts
</span><span class="line">Info: Caching catalog for c02n5heug3qj
</span><span class="line">Info: Applying configuration version '1449305286'
</span><span class="line">Notice: Test Role
</span><span class="line">Notice: /Stage[main]/Roles::Test/Notify[Test Role]/message: defined 'message' as 'Test Role'
</span><span class="line">Notice: Default Role
</span><span class="line">Notice: /Stage[main]/Roles::Default/Notify[Default Role]/message: defined 'message' as 'Default Role'
</span><span class="line">Notice: Common Profile
</span><span class="line">Notice: /Stage[main]/Profiles::Common/Notify[Common Profile]/message: defined 'message' as 'Common Profile'
</span><span class="line">Notice: Test Profile
</span><span class="line">Notice: /Stage[main]/Profiles::Test/Notify[Test Profile]/message: defined 'message' as 'Test Profile'
</span><span class="line">Notice: Finished catalog run in 13.84 seconds</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="additional-notes">Additional Notes</h3>

<p>Whenever you make a change to your Core Repo, you also need to manually tell your Puppetserver to pull in the changes.  This can be done by running this on the server:</p>

<div class="bogus-wrapper"><notextile><figure class="code panel panel-default"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">docker exec -it puppetserver r10k deploy environment -pv</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Yay! We’ve made it to the end and we now have a functional Puppetserver! If you’ve made it this far give yourself a pat on the back, it took me much longer to get up and running with Puppet when I first started.</p>

<p>Here’s a few quick notes:</p>

<ol>
  <li>This is a new Docker image and could have some bugs and issues.  I’m relying on the community to help identify these issues.</li>
  <li>I’m not an expert at this, I just started using puppet a few months ago myself.  If you see areas that could be improved feel free to submit a pull request.
    <ol>
      <li>The Puppetserver code can be found <a href="https://github.com/MichaelHoltTech/puppetserver"><strong>here</strong></a>.</li>
      <li>The Core Repo code can be found <a href="https://github.com/MichaelHoltTech/puppet-core_repo/"><strong>here</strong></a>.</li>
      <li>The Base Image code can be found <a href="https://github.com/MichaelHoltTech/baseimage"><strong>here</strong></a>.  It is based off of work done by phusion, located <a href="https://github.com/phusion/baseimage-docker"><strong>here</strong></a>.</li>
    </ol>
  </li>
  <li>I’m currently not running this Image in Production.  I plan on moving over to it after the Christmas Holidays as I continue to document our Management Platform.</li>
</ol>

<p>Stay Tuned for the next post! No promises but i’ll see if I can at least get one more post up documenting how to begin programming some configuration options.  If I don’t get to it, I’ll definitely have time in January! (I’ll do my best not to keep you waiting 2 months this time)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Our Path to Mac Management]]></title>
    <link href="http://www.mholt.tech/blog/2015/10/08/our-path-to-mac-management/"/>
    <updated>2015-10-08T19:48:15-07:00</updated>
    <id>http://www.mholt.tech/blog/2015/10/08/our-path-to-mac-management</id>
    <content type="html"><![CDATA[<h3 id="where-we-started">Where we Started</h3>

<blockquote>
  <p>“In the beginning God created…” the Mac… “and it was good”</p>
</blockquote>

<p>Ok maybe I went a little far in that one.  I came on staff at Real Life Church in 2012 and at that time we were mostly a PC shop with the exception being Pastors exclusively having a Mac (With Local Admin Access and no admin account for IT).  Over the next 2 years we realized that we got significantly more support requests on our PCs than for our Macs. We were running on an aging SBS 2008 server that was maxed out on licensing and we were continuing to grow.  After numerous conversations with my Director and leadership the decision was clear that we needed to make the transition to a 100% Mac shop in our church.</p>

<!--more-->

<p>This decision was based on the need to purchase new hardware and spend hundreds of man hours (as the solo IT Admin) in building out a new server infrastructure to manage the windows Machines with no guarantee that it would cut down on the ongoing support needs.  The direction was clear at the beginning of 2014 that we would be transitioning to the Macs as soon as we had the capital to spend on them.</p>

<p>Knowing this, I began to research and address ways to manage software, patches, and support the new influx of Macs.</p>

<h3 id="introducing-the-munki">Introducing the Munki</h3>

<p><img src="https://lh3.googleusercontent.com/-SZsDtJV44Ic/T8ytQjvo24I/AAAAAAAAAlc/A4b9DjdBWGk/s640/blogger-image-1072467874.jpg" alt="alt text" title="Oh No, Monkeys on a Mac! - Image courtesy of http://nikiwallacedesign.blogspot.com/2012/06/think-first-design-later.html" /></p>

<p>Ok so I’m not actually talking about a real Monkey here.  Munki is a set of tools that can be used to manage software installs on OS X Client Machines.  It was developed by Gregg Neagle (@gregneagle) at Walt Disney Animation Studios and was open sourced for anyone to use and contribute to.  I had heard about Munki a couple of times in discussions with Churches and other people about how to manage a Mac and finally decided to start looking into it.  In addition to do managed and optional installs as well as updates of 3rd party software, it is also capable of installing Apple Software Updates.</p>

<h3 id="our-requirements-for-staff-macs">Our Requirements for Staff Macs</h3>

<p>One of the first things we decided on was some of the requirements and restrictions that we wanted in place on the Mac.  Every organization is different but this is where we settled.</p>

<ol>
  <li>
    <p>No end user will be an administrator on their Machine</p>
  </li>
  <li>
    <p>Only approved software can be installed and can be found inside Munki</p>
  </li>
  <li>
    <p>No App Store apps allowed
One of the continuous debates is Admin vs No Admin regardless of platform (Mac vs PC).  We decided on the no admin approach because we did not want our staff being able to install unapproved software or changing system settings that could negatively affect their Machine.</p>
  </li>
</ol>

<h3 id="challenges">Challenges</h3>

<p>I spent about 10 months developing our Munki infrastructure and learning how it worked.  Part of the reason for taking this long is when first evaluating it at the beginning of the year there was already progress being made on version 2 that turned Munki into a replica of the Apple App Store in terms of layout and usability.</p>

<p>The primary opposition we faced was a number of employees responded with: “I’ve always used a PC and have never touched a Mac, how am I supposed to get my job done?”  We encouraged our users to keep an open mind and we spent time with them after migrating their data showing them the basics of how to use a Mac and spending 15-20 minutes showing them the basics on how to open documents and applications.  Within a few months I was hearing from everyone that they “loved” their Macs and are glad to have them.</p>

<h3 id="issues-with-non-admins-and-munki">Issues with Non-Admins and Munki</h3>

<p>After a few months in we started finding a few issues with our configuration and stance of no Local Admin access.  This included:</p>

<ol>
  <li>
    <p>Users could not change their energy saver preferences</p>
  </li>
  <li>
    <p>Users could not install home printers</p>
  </li>
  <li>
    <p>Printers would “pause” when running out of paper or toner, and paper jams. Admin credentials were required to resume printing</p>
  </li>
  <li>
    <p>Management of software updates became cumbersome and users were requesting software that would have been available in the Mac App Store</p>
  </li>
</ol>

<h3 id="our-next-steps">Our Next Steps</h3>

<p>We have been using Munki for a year now and when re-evaluating our setup and options we discovered that we were spending significantly more than we had anticipated by running our system on Amazon EC2.  We also wanted to address some underlying issues with configuration management, printers, and opening up the App Store.  This led us to make some new changes which I will highlight here and detail further in future blog posts.</p>

<p>We decided to go with the following systems to comprise our Mac Management Solution:</p>

<ol>
  <li>
    <p><a href="https://github.com/google/simian"><strong>Simian</strong></a>, a backend solution to power the Munki client, hosted on Google App Engine and developed by Google MacOps, along with customizations to Munki to create a secure connection between the client and server.</p>
  </li>
  <li>
    <p><a href="https://puppetlabs.com/"><strong>Puppet</strong></a>, a configuration management system that allows you to define the state of your Machines.</p>
  </li>
  <li>
    <p><a href="https://github.com/Munkireport/Munkireport-php"><strong>Munkireport-php</strong></a>, a powerful system reporting utility that provides detailed system information on your Macs</p>
  </li>
  <li>
    <p><a href="https://github.com/grahamgilbert/Crypt"><strong>Crypt</strong></a>, a Filevault Key Escrow solution built by Graham Gilbert for recording filevault recovery keys</p>
  </li>
  <li>
    <p><a href="https://github.com/grahamgilbert/Macnamer"><strong>Macnamer</strong></a>, a web app and Mac script that runs on your Mac to force your Machine to follow a naming convention with an automatically generated number suffix. Another solution built by Graham Gilbert</p>
  </li>
  <li>
    <p><a href="https://github.com/salopensource/sal"><strong>Sal</strong></a>, a Multi-Tennant reporting dashboard similar to Munkireport that provides another way of viewing system information.</p>
  </li>
  <li>
    <p><a href="https://github.com/autopkg/autopkg"><strong>Autopkg</strong></a>, automates the download and manifest creation of software for import into simian.  This is not fully automated but allows me to simply copy paste into Simian to provide updates.</p>
  </li>
  <li>
    <p><a href="https://github.com/lindegroup/autopkgr"><strong>Autopkgr</strong></a>, ties into Autopkg and checks for software updates every night and sends an email alert when software updates are installed</p>
  </li>
  <li>
    <p><a href="https://www.screenconnect.com/"><strong>Screenconnect</strong></a>, an Unattended Remote Support software for Mac/PC/Linux.  We use this to be able to remotely support our Users.</p>
  </li>
  <li>
    <p><strong>Not Yet Implemented</strong> - <a href="https://github.com/grahamgilbert/imagr"><strong>Imagr</strong></a>, an open source replacement to DeployStudio for workstation imaging and thin-provisioning.</p>
  </li>
</ol>

<p>Everything except Simian runs inside a single server on Digital Ocean inside of Docker Containers.  I plan on publishing additional information on my setup and instructions on how to create this setup in the near future.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Pi Cam Matrix V2]]></title>
    <link href="http://www.mholt.tech/blog/2015/08/29/pi-cam-matrix-v2/"/>
    <updated>2015-08-29T09:50:39-07:00</updated>
    <id>http://www.mholt.tech/blog/2015/08/29/pi-cam-matrix-v2</id>
    <content type="html"><![CDATA[<p>After a few days in production I discovered that over time the Pi’s would lose connection to the RTSP feeds.  The only two ways to resolve this were to reboot the Pi or SSH into the Pi.  Because of this I started back at the beginning and was able to develop another way of running this matrix that would automatically reload the RTSP feed if it was lost.  The initial Pi Setup instructions are identical to my last post, <a href="http://www.mholt.tech/blog/2015/08/21/raspberry-pi-camera-matrix/">Raspberry Pi Camera Matrix</a>, the differences come in with setting up the new code base.</p>

<p>For those that are interested in how to make this happen here’s the instructions and code:</p>

<p><strong>What you’ll need:</strong></p>

<ul>
  <li>Raspberry Pi2 (I got the Canakit Raspberry Pi 2 - Complete Starter Kit off of Amazon, comes with everything you need for this project)</li>
  <li>Unifi NVR Software running the most recent stable release</li>
  <li>HDTV or Computer Monitor capable of 1080p</li>
  <li>MicroSD to SD Card Adapter (Optional, only needed if you have to re-install raspbian)</li>
  <li>Keyboard for initial setup</li>
</ul>

<!--more-->

<h3 id="instructions">Instructions</h3>
<ol>
  <li>
    <p><strong>Put together and connect you PI2</strong></p>

    <p>Refer to the quick-start guide that is in the Box in order to get started with your Raspberry Pi and install Raspbian using the pre-loaded NOOBS installer on the SD Card</p>
  </li>
  <li>
    <p><strong>Configure Raspbian</strong></p>

    <p>Once you arrive at the Raspi-Config screen you should change the default password (Option 2), set a hostname (Option 8 - A2), set Memory split for video to 512 (Option 8 - A3), and overclock (Option 7 - Pi2).</p>

    <p>After this is done click finish and you will be dropped to the command line. I have found the overclocking to help with the videos loading initially, otherwise i’ve found it to take a minute or two for cameras to play smoothly.</p>

    <p>For more information on raspi-config, see <a href="https://www.raspberrypi.org/documentation/configuration/raspi-config.md">https://www.raspberrypi.org/documentation/configuration/raspi-config.md</a></p>
  </li>
  <li>
    <p><strong>Get the code</strong></p>

    <p>Clone the PiCamMatrix repo into /home/pi using</p>

    <p><code>git clone https://github.com/MichaelHoltTech/PiCamMatrix.git</code></p>

    <p>Note: If you wish to use a different path, you need to <code>Script=</code> in every file to point to the path that the scripts reside.</p>
  </li>
  <li>
    <p><strong>Edit the files for your configuration</strong></p>

    <ul>
      <li>
        <p>cd into PiCamMatrix by entering:</p>

        <p><code>cd ~/PiCamMatrix</code></p>
      </li>
      <li>
        <p>edit cams.txt by typing:</p>

        <p><code>nano cams.txt</code></p>
      </li>
      <li>
        <p>replace <rtsp_url_using_ip> with the RTSP url's for your cameras (I recommend using the Low Quality to save bandwidth and using an IP Address instead of FQDN to ensure no issues arrise.)  This url can be found in the NVR under RTSP Service when editing a camera</rtsp_url_using_ip></p>
      </li>
      <li>
        <p>exit nano by hitting ctrl + x then entering y to save and enter to keep the filename</p>
      </li>
      <li>
        <p>Configure a Static IP address in <code>/etc/network/interfaces</code>.  I highly recommend wired instead of wireless.  If you need some instructions on setting a static IP this tutorial is very easy to follow: <a href="http://www.modmypi.com/blog/tutorial-how-to-give-your-raspberry-pi-a-static-ip-address">http://www.modmypi.com/blog/tutorial-how-to-give-your-raspberry-pi-a-static-ip-address</a></p>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>Create SymLinks to init.d</strong></p>

    <ul>
      <li>
        <p>While still inside of ~/PiCamMatrix run this in order to link the init.d scripts to /etc/init.d:</p>

        <p><code>
sudo ln -s /home/pi/PiCamMatrix/init.d/camtopleft /etc/init.d/camtopleft
sudo ln -s /home/pi/PiCamMatrix/init.d/camtopright /etc/init.d/camtopright
sudo ln -s /home/pi/PiCamMatrix/init.d/cambottomleft /etc/init.d/cambottomleft
sudo ln -s /home/pi/PiCamMatrix/init.d/cambottomright /etc/init.d/cambottomright
</code></p>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>Enable the scripts to automatically start at boot</strong></p>

    <ul>
      <li>Run these commands while still inside ~/PiCamMatrix in order for the cameras feeds to automatically load at boot:</li>
    </ul>

    <p><code>
 sudo update-rc.d camtopleft defaults
 sudo update-rc.d camtopright defaults
 sudo update-rc.d cambottomleft defaults
 sudo update-rc.d cambottomright defaults
</code></p>
  </li>
  <li>
    <p><strong>Reboot the Pi</strong></p>

    <p>At this point all of your configuration is done.  All that’s left to do is reboot the Pi and let the cameras load up.  Enter this command to tell the Pi to reboot:</p>

    <p><code>sudo reboot</code></p>
  </li>
</ol>

<h3 id="troubleshooting">Troubleshooting</h3>

<ul>
  <li>
    <p><strong>Display Issues:</strong></p>

    <p>If you’re having strange display issues, such as banding, flickering, or the display just shuts off, it’s somewhat expected for the Raspberry Pi.  To troubleshoot, you’re going to have to make some changes to the /boot/config.txt file in order to force certain modes and resolutions.   The included config.txt works for my setup but your milage may vary depending on your TV/Monitor.</p>
  </li>
  <li>
    <p><strong>Starting with a Fresh Raspbian Install:</strong></p>

    <p>This is where you are going to need that option MicroSD to SD Card adapter.  I’m not going to cover how to do that because the instructions are easily found on the internet.  Easiest ones to follow are at <a href="https://www.raspberrypi.org/documentation/installation/noobs.md">https://www.raspberrypi.org/documentation/installation/noobs.md</a></p>
  </li>
  <li>
    <p><strong>Changing RTSP URL’s:</strong></p>

    <p>This easiest way to update your RTSP URL’s is to edit the files that were copied from the git folder onto your pi.  This can be done by running:</p>

    <p><code>nano ~/cams.txt</code></p>
  </li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Raspberry Pi Camera Matrix]]></title>
    <link href="http://www.mholt.tech/blog/2015/08/21/raspberry-pi-camera-matrix/"/>
    <updated>2015-08-21T14:46:39-07:00</updated>
    <id>http://www.mholt.tech/blog/2015/08/21/raspberry-pi-camera-matrix</id>
    <content type="html"><![CDATA[<h2 id="i-have-posted-version-2-of-this-script-herehttpwwwmholttechblog20150829pi-cam-matrix-v2">I have posted version 2 of this script <a href="http://www.mholt.tech/blog/2015/08/29/pi-cam-matrix-v2/">HERE</a></h2>
<p>Over the last few months we’ve been upgrading our Security Cameras, replacing a 10 year old vitek system with the Ubiquiti Unifi Video system.  We just finished installing the last of these Cameras and that included the need to find a new solution for our Children’s Cameras to be displayed onto two TV’s.  I found a Forum Post on the Ubiquiti Community that documented one person’s script to display a <a href="http://community.ubnt.com/t5/UniFi-Video/Tutorial-Raspberry-Pi-4-Cam-Matrix-Viewer-Appliance/m-p/1253309#U1253309">2x2 Camera Matrix on a Raspberry Pi</a></p>

<p>So I went ahead and order 2x Raspberry Pi’s to power both of these displays and thought “Perfect, someone else has done the leg work all I have to do is plug in the RTSP URL’s and presto”.  Unfortunatly, I ran into some issues with screen causing the video to jump a few seconds instead of playing smoothly.  I also couldn’t get the code working as an init.d so I took a different approach using rc.local.</p>

<p>For those that are interested in how to make this happen here’s the instructions and code:</p>

<p><strong>What you’ll need:</strong></p>

<ul>
  <li>Raspberry Pi2 (I got the Canakit Raspberry Pi 2 - Complete Starter Kit off of Amazon, comes with everything you need for this project)</li>
  <li>Unifi NVR Software running the most recent stable release</li>
  <li>HDTV or Computer Monitor capable of 1080p</li>
  <li>MicroSD to SD Card Adapter (Optional, only needed if you have to re-install raspbian)</li>
  <li>Keyboard for initial setup</li>
</ul>

<!--more-->

<h3 id="instructions">Instructions</h3>
<ol>
  <li>
    <p><strong>Put together and connect you PI2</strong></p>

    <p>Refer to the quick-start guide that is in the Box in order to get started with your Raspberry Pi and install Raspbian using the pre-loaded NOOBS installer on the SD Card</p>
  </li>
  <li>
    <p><strong>Configure Raspbian</strong></p>

    <p>Once you arrive at the Raspi-Config screen you should change the default password (Option 2) and set a hostname (Option 8 - A2).</p>

    <p>After this is done click finish and you will be dropped to the command line. Overclocking is also possible, but not required or recommended for what we are doing.</p>

    <p>For more information on raspi-config, see <a href="https://www.raspberrypi.org/documentation/configuration/raspi-config.md">https://www.raspberrypi.org/documentation/configuration/raspi-config.md</a></p>
  </li>
  <li>
    <p><strong>Get the code</strong></p>

    <p>You can get the code from GitHub by entering:</p>

    <p><code>git clone https://gist.github.com/dde9de96b6a4d72b7f58.git raspicams</code></p>
  </li>
  <li>
    <p><strong>Edit the files for your configuration</strong></p>

    <ul>
      <li>
        <p>cd into raspicams by entering:</p>

        <p><code>cd ~/raspicams</code></p>
      </li>
      <li>
        <p>edit cams.sh by typing:</p>

        <p><code>nano cams.sh</code></p>
      </li>
      <li>
        <p>replace <rtsp_url_using_ip> with the RTSP url's for your cameras (I recommend using the Low Quality to save bandwidth and using an IP Address instead of FQDN to ensure no issues arrise.)  This url can be found in the NVR under RTSP Service when editing a camera</rtsp_url_using_ip></p>
      </li>
      <li>
        <p>exit nano by hitting ctrl + x then entering y to save and enter to keep the filename</p>
      </li>
      <li>
        <p>edit network-interfaces and set static IP address configuration for eth0 (Optional but Highly Recommended)</p>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>Copy the files into place</strong></p>

    <ul>
      <li>
        <p>While still inside of ~/raspicams run this in order to copy all of these files into place:</p>

        <p><code>sudo chown root:root boot-config.txt network-interfaces rc.local cmdline.txt &amp; sudo chmod +x * &amp; sudo cp boot-config.txt /boot/config.txt &amp; sudo cp cmdline.txt /boot/cmdline.txt &amp; sudo cp rc.local /etc/rc.local &amp; sudo cp cams.sh ~/cams.sh</code></p>
      </li>
      <li>
        <p>If you have also configured a static IP in network-interfaces run this command to copy that file into place:</p>

        <p><code>sudo cp network-interfaces /etc/network/interfaces</code></p>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>Reboot the Pi</strong></p>

    <p>At this point all of your configuration is done.  All that’s left to do is reboot the Pi and let the cameras load up.  Enter this command to tell the Pi to reboot:</p>

    <p><code>sudo reboot</code></p>
  </li>
</ol>

<h3 id="troubleshooting">Troubleshooting</h3>

<ul>
  <li>
    <p><strong>Display Issues:</strong></p>

    <p>If you’re having strange display issues, such as banding, flickering, or the display just shuts off, it’s somewhat expected for the Raspberry Pi.  To troubleshoot, you’re going to have to make some changes to the /boot/config.txt file in order to force certain modes and resolutions.   The included config.txt works for my setup but your milage may vary depending on your TV/Monitor.</p>
  </li>
  <li>
    <p><strong>Starting with a Fresh Raspbian Install:</strong></p>

    <p>This is where you are going to need that option MicroSD to SD Card adapter.  I’m not going to cover how to do that because the instructions are easily found on the internet.  Easiest ones to follow are at <a href="https://www.raspberrypi.org/documentation/installation/noobs.md">https://www.raspberrypi.org/documentation/installation/noobs.md</a></p>
  </li>
  <li>
    <p><strong>Changing RTSP URL’s:</strong></p>

    <p>This easiest way to update your RTSP URL’s is to edit the files that were copied from the git folder onto your pi.  This can be done by running:</p>

    <p><code>nano ~/cams.sh</code></p>
  </li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Welcome to My Blog!]]></title>
    <link href="http://www.mholt.tech/blog/2015/08/10/welcome-to-my-blog/"/>
    <updated>2015-08-10T21:02:17-07:00</updated>
    <id>http://www.mholt.tech/blog/2015/08/10/welcome-to-my-blog</id>
    <content type="html"><![CDATA[<p>Hey Guys! Thanks for checking out my blog.</p>

<p>I don’t have much here yet but I soon hope to start posting some of my setup and code soon to use Munki, PuppetServer, Simain, Sal, MunkiReport, Crypt, MacNamer, and Imagr to set up a full fledged automated mac management configuration and reporting solution.</p>
]]></content>
  </entry>
  
</feed>
